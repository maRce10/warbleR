---
title: <font size="7"><b>warbleR&#58; Annotation data format</b></font>
pagetitle: Annotation data format
author: 
- <a href="https://marce10.github.io">Marcelo Araya-Salas, PhD</a> 
date:  "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    self_contained: yes
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
vignette: >
   %\VignetteIndexEntry{2. Annotation data format}
   %\usepackage[utf8]{inputenc}
   %\VignetteEncoding{UTF-8}
   %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

<!-- skyblue box -->
<div class="alert alert-info">

This vignette explains in detail the structure of the **R** data objects containing sound file annotations that are required by the package **warbleR**.

</div>


```{r extn_sel_2, echo = FALSE, message = FALSE}

rm(list = ls())

# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))

#load packages
library(warbleR)
library(knitr)
library(kableExtra)


# cf <- read.csv("./data/cuadro de funciones warbleR.csv", stringsAsFactors = FALSE)

# warbleR_options(wav.path = "./examples") 

options(knitr.table.format = "html") 
opts_chunk$set(comment = "")
opts_knit$set(root.dir = tempdir())
options(width = 100, max.print = 100)

```

<img src="warbleR_sticker.png" alt="warbleR logo" align="right" width="25%" height="25%">


An annotation table (or selection table in Raven's and warbleR's terminology) is a data set that contains information about the location in time (and sometimes in frequency) of the sounds of interest in one or more sound files. **warbleR** can take sound file annotations represented in the following **R** objects: 

 - Data frames
 - Selection tables
 - Extended selection tables
 
The last 2 are annotation specific R classes included in **warbleR**. Here we described the basic structure of these objects and how they can be created.


# Data frames

Data frames with sound file annotations must contain the following columns: 

 1) 'sound.files': character or factor column name of the sound files including the file extension (e.g. "rec_1.wav")
 1) 'selec': numeric, character or factor column with a unique identifier (at least within each sound file) for each annotation (e.g. 1, 2, 3 or "a", "b", "c")
 1) 'start': the start position in time of an annotated sound (in seconds)
 1) 'end': the end position in time of an annotated sound (in seconds)

```{r, echo = FALSE}

options(digits=3)

set.seed(123)

start <- runif(n = 4, min = 0.2, max = 10)

cd.anot <-
  data.frame(sound.files = rep(c("sound_file_1.wav", "sound_file_2.wav"), each = 2),
             selec = rep(1:2, 2), 
             start, 
             end =  start + abs(rnorm(n = 4, mean = 1)))


kbl <- knitr::kable(cd.anot, align = "c", row.names = F,  format = "html")

kbl <-  kableExtra::kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl

```

Data frames containing annotations can also include the following optional columns: 

 - 1) 'bottom.freq': numeric column with the bottom frequency of the frequency range of the annotation (in kHz)
 - 1) 'top.freq': numeric column with the top frequency of the frequency range of the annotation (in kHz)
 - 1) 'channel': numeric column with the number of the channel in which the annotation is found in a multi-channel sound file (by default is 1)

```{r, echo = FALSE}

cd.anot$bottom.freq <- rnorm(n = 4, mean = 5)
cd.anot$top.freq <- rnorm(n = 4, mean = 9)

cd.anot$channel <- rep(1, 4)

# cd.anot <- cd.anot[, c(1, 7, 2:6)]

kbl <- knitr::kable(cd.anot, align = "c", row.names = F,  format = "html")


kbl <-  kableExtra::kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl

```

The sample data "lbh_selec_table" contains a data frame with annotations with the format expected by **warbleR**:

```{r extn_sel_4.1, eval=FALSE}

library(warbleR)

data("lbh_selec_table")


knitr::kable(lbh_selec_table)
```

```{r extn_sel_4.2, echo=FALSE}

kbl <- knitr::kable(lbh_selec_table, align = "c", row.names = F,  format = "html")

kbl <-  kableExtra::kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl
```

Typically, annotations are created in other sound analysis programs (mainly, Raven, Avisoft, Syrinx and Audacity) and then imported into *R*. We recommend annotating sound files in [Raven sound analysis software](http://www.birds.cornell.edu/brp/raven/RavenOverview.html) ([Cornell Lab of Ornithology](http://www.birds.cornell.edu)) and then importing them into **R** with the package [**Rraven**](https://marce10.github.io/Rraven/). This package facilitates data exchange between R and [Raven sound analysis software](http://www.birds.cornell.edu/brp/raven/RavenOverview.html) and allow users to import annotation data into R using the **warbleR** annotation format (see argument 'warbler.format' in the function `imp_raven()`).

<!-- light brown box -->
<div class="alert alert-warning">

Data frames containing annotations always refer to sound files. Therefore, when using data frames users *must always indicate the location of the sound files* to every **warbleR** function when providing annotations in this format.

</div>


# warbleR annotation formats

## Selection tables

These objects are created with the `selection_table()` function. The function takes data frames containing annotation data as in the format described above. Therefore the same mandatory and optional columns are used by selection tables. The function verifies if the information is consistent (see the function `check_sels()` for details) and saves the 'diagnostic' metadata as an attribute in the output object. Selection tables are basically data frames in which the information contained has been double checked to ensure it can be read by other **warbleR** functions.

Selection tables are created by the function `selection_table()`:

```{r extn_sel_4.32, eval = FALSE}

# write example sound files in temporary directory
writeWave(Phae.long1, file.path(tempdir(), "Phae.long1.wav"))
writeWave(Phae.long2, file.path(tempdir(), "Phae.long2.wav"))
writeWave(Phae.long3, file.path(tempdir(), "Phae.long3.wav"))
writeWave(Phae.long4, file.path(tempdir(), "Phae.long4.wav"))
  
st <-
  selection_table(X = lbh_selec_table, path = tempdir())

knitr::kable(st)
```

```{r, eval = TRUE, echo = FALSE}

writeWave(Phae.long1, file.path(tempdir(), "Phae.long1.wav"))
writeWave(Phae.long2, file.path(tempdir(), "Phae.long2.wav"))
writeWave(Phae.long3, file.path(tempdir(), "Phae.long3.wav"))
writeWave(Phae.long4, file.path(tempdir(), "Phae.long4.wav"))

# global parameters
st <- selection_table(X = lbh_selec_table, pb = FALSE, path = tempdir())

kbl <- knitr::kable(st)

kbl <-  kableExtra::kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl

```

Selection table is an especific object class that have their own printing method: 
```{r}

class(st)

st
```

Note that the path to the sound files must be provided. This is necessary in order to verify that the data provided conforms to the characteristics of the audio files.

<!-- light brown box -->
<div class="alert alert-warning">

Selection table also refer to sound files. Therefore, users **must always indicate the location of the sound files to every *warbleR* function** when providing annotations in this format

</div>


## Extended selection tables

Extended selection tables are annotations that include both the acoustic and annotation data. This an specific object class, *extended_selection_table*, that include a list of 'wave' objects corresponding to each of the selections in the data. Therefore, the function **transforms the selection table into self-contained objects** since the original sound files are no longer needed to perform most of the acoustic analysis in **warbleR**. This can facilitate the storage and exchange of (bio)acoustic data. This format can also speed up analyses, since it is not necessary to read the sound files every time the data is analyzed.

The `selection_table()` function also creates extended selection tables. To do this, users must set the argument `extended = TRUE` (otherwise, the class would be a selection table). The following code converts the exaample 'lbh_selec_table' data into an extended selection table:

```{r extn_sel_4.3, eval = FALSE}

ext_st <- selection_table(X = lbh_selec_table, pb = FALSE, 
          extended = TRUE, path = tempdir())

```

```{r extn_sel_4.33, eval = TRUE, echo = FALSE}

ext_st <- selection_table(X = lbh_selec_table, pb = FALSE, 
          extended = TRUE, path = tempdir())


```


Extended selection table is an especific object class that have their own printing method: 
```{r}

class(ext_st)

ext_st

```


### Handling extended selection tables

Several functions can be used to deal with objects of this class. First can test if the object belongs to the *extended_selection_table*:

```{r extn_sel_5}

is_extended_selection_table(ext_st)
```


You can subset the selection in the same way that any other data frame and it will still keep its attributes:

```{r extn_sel_6}

ext_st2 <- ext_st[1:2, ]

is_extended_selection_table(ext_st2)
```

There is also a generic version of `print()` for this class of objects:

```{r extn_sel_7}

## print
print(ext_st)
```

... which is equivalent to:

```{r extn_sel_7.1, eval=FALSE}

ext_st
```

```{r extn_sel_7/2, echo=FALSE}

print(ext_st)
```

You can also join them in rows. Here the original *extended_selection_table* is divided into 2 and bound again using `rbind()`:

```{r extn_sel_8, eval = FALSE}

ext_st3 <- ext_st[1:5, ]

ext_st4 <- ext_st[6:11, ]

ext_st5 <- rbind(ext_st3, ext_st4)

# print
ext_st5
```

```{r extn_sel_8.1, echo=FALSE}

ext_st3 <- ext_st[1:5, ]

ext_st4 <- ext_st[6:11, ]

ext_st5 <- rbind(ext_st3, ext_st4)

# print
print(ext_st5)
```

```{r extn_sel_8.2}

# same annotations
all.equal(ext_st, ext_st5, check.attributes = FALSE)

# same acoustic data
all.equal(attr(ext_st, "wave.objects"), attr(ext_st5, "wave.objects"))

```


The 'wave' objects can be read individually using `read_sound_file()`, a wrapper for the `readWave()` function from **tuneR**, which can handle extended selection tables:

```{r extn_sel_8.21}

wv1 <- read_sound_file(X = ext_st, index = 3, from = 0, to = 0.37)
```


These are regular 'wave' objects:

```{r extn_sel_8.22, out.width= 750}

class(wv1)

wv1

spectro(wv1, wl = 150, grid = FALSE, scale = FALSE, ovlp = 90)
```

 

```{r extn_sel_8.23, out.width= 750}
par(mfrow = c(3, 2), mar = rep(0, 4))

for (i in 1:6) {
  wv <- read_sound_file(X = ext_st, index = i, from = 0.05, to = 0.32)

  spectro(wv,
    wl = 150, grid = FALSE, scale = FALSE, axisX = FALSE,
    axisY = FALSE, ovlp = 90
  )
}
```


The `read_sound_file()` function requires a selection table, as well as the row index (i.e. the row number) to be able to read the 'wave' objects. It can also read a regular 'wave' file if the path is provided.

Note that other functions that modify data frames are likely to delete the attributes in which the 'wave' objects and metadata are stored. For example, the merge and the extended selection box will remove its attributes:

```{r extn_sel_8.24}

# create new data frame
Y <- data.frame(sound.files = ext_st$sound.files, site = "La Selva", lek = c(rep("SUR", 5), rep("CCL", 6)))

# combine
mrg_ext_st <- merge(ext_st, Y, by = "sound.files")

# check class
is_extended_selection_table(mrg_ext_st)
```


In this case, we can use the `fix_extended_selection_table()` function to transfer the attributes of the original extended selection table:

```{r extn_sel_8.25}

# fix est
mrg_ext_st <- fix_extended_selection_table(X = mrg_ext_st, Y = ext_st)

# check class
is_extended_selection_table(mrg_ext_st)
```


This works as long as some of the original sound files are retained and no other selections are added.


 
Finally, these objects can be used as input for most **warbleR** functions, without the need of refering to any sound file. For instance we can easily measure acoustic parameters on data in *extended_selection_table* format using the function `spectro_analysis()`:

```{r extn_sel_12.1, eval=FALSE}

#  parametros espectrales
sp <- spectro_analysis(ext_st)

# check first 10 columns
sp[, 1:10]
```


```{r, eval = TRUE, echo = FALSE}

sp <- spectro_analysis(ext_st)

kbl <- knitr::kable(sp[, 1:10])

kbl <-  kableExtra::kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl
```

 

### Performance

The use of *extended_selection_table* objects can improve performance (in our case, measured as time). Here we use **microbenchmark** to compare the performance of `sig2noise()` and **ggplot2** to plot the results. First, a selection table with 1000 selections is created simply by repeating the sample data frame several times and then is converted to an extended selection table:

```{r extn_sel_13, eval = FALSE}

# create long selection table
lng.selec.table <- do.call(rbind, replicate(10, lbh_selec_table,
  simplify = FALSE
))

# relabels selec
lng.selec.table$selec <- 1:nrow(lng.selec.table)

# create extended selection table
lng_ext_st <- selection_table(
  X = lng.selec.table, 
  pb = FALSE,
  extended = TRUE
  )


# load packages
library(microbenchmark)
library(ggplot2)

# check performance
mbmrk.snr <- microbenchmark(extended = sig2noise(lng_ext_st,
  mar = 0.05
), regular = sig2noise(lng.selec.table,
  mar = 0.05
), times = 50)

autoplot(mbmrk.snr) + ggtitle("sig2noise")
```


<center> ![autodetec image example](microbenchmark.png)</center>




The function runs much faster in the extended selection tables. Performance gain is likely to improve when longer recordings and data sets are used (that is, to compensate for computing overhead).



### Sharing acoustic data

This new object class allows to share complete data sets, including acoustic data. For example, the **NatureSounds** package contains an extended selection table with long-billed hermit hummingbirds vocalizations from 10 different song types:
  
```{r}

data("Phae.long.est")

Phae.long.est

table(Phae.long.est$lek.song.type)
```

The ability to compress large data sets and the ease of performing analyzes that require a single R object can simplify the exchange of data and the reproducibility of bioacoustic analyzes.

------------------------------------------------------------------------

## References

-   Araya-Salas (2017), *Rraven: connecting R and Raven bioacoustic software*. R package version 1.0.2.

------------------------------------------------------------------------


<font size="4">Session information</font>

```{r session info, echo=F}

sessionInfo()

```
