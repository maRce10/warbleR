#' Optimize the detection of signals based on a-priori detections
#' @usage optimize_find_peaks(xc.output, reference, cutoffs = NULL, parallel = 1,
#'  pb = FALSE, by.sound.file = FALSE, previous.output = NULL)
#' @param xc.output An object of class 'xcorr.output' (generated by \code{\link{cross_correlation}}) in which to optimize detections. Must refer to the same sound files as in 'X'.
#' @param reference Data frame or 'selection.table' with the reference selections (start and end of the signals) that will be used to evaluate the performance of the detection, represented by those selections in 'detection'. Must contained at least the following columns: "sound.files", "selec", "start" and "end".
#' @param cutoffs Numeric vector with the cutoff values to be tested for optimization. Default is \code{NULL}.
#' @param parallel Numeric. Controls whether parallel computing is applied.
#'  It specifies the number of cores to be used. Default is 1 (i.e. no parallel computing).
#' @param pb Logical argument to control progress bar and messages. Default is \code{TRUE}.
#' @param by.sound.file Logical to control if diagnostics are calculated for each sound file independently (\code{TRUE}) or for all sound files combined (\code{FALSE}, default).
#' @param previous.output Data frame with the output of a previous run of this function. This will be used to include previous results in the new output and avoid recalculating detection performance for parameter combinations previously evaluated.
#' @return A data frame in which each row shows the result of a detection job for each cutoff value, including the following diagnostic metrics:
#' \itemize{
#'  \item \code{true.positives}: number of detections that correspond to signals referenced in 'X'. Matching is defined as some degree of overlap in time. In a perfect detection routine it should be equal to the number of rows in 'X'. 
#'  \item \code{false.positives}: number of detections that don't match any of the signals referenced in 'X'. In a perfect detection routine it should be 0.    
#'  \item \code{split.positives}: number of signals referenced in 'X' that were overlapped by more than 1 detection (i.e. detections that were split). In a perfect detection routine it should be 0.
#'  \item \code{sensitivity}: Proportion of signals referenced in 'X' that were detected. In a perfect detection routine it should be 1.
#'  \item \code{specificity}: Proportion of detections that correspond to signals referenced in 'X' that were detected. In a perfect detection routine it should be 1.
#'  } 
##' @export
#' @name optimize_find_peaks
#' @details This function takes a selections data frame or 'selection_table' ('X') and the output of a \code{\link{auto_detec}} routine ('xc.output') and estimates the detection performance for different detection parameter combinations. This is done by comparing the position in time of the detection to those of the reference selections in 'X'. The function returns several diagnostic metrics to allow user to determine which parameter values provide a detection that more closely matches the selections in 'X'. Those parameters can be later used for performing a more efficient detection using \code{\link{auto_detec}}.
#'
#' @examples{
#' # Save sound files to temporary working directory
#' data(list = c("Phae.long4", "Phae.long2", "lbh_selec_reference"))
#' writeWave(Phae.long2, file.path(tempdir(), "Phae.long2.wav"))
#' writeWave(Phae.long4, file.path(tempdir(), "Phae.long4.wav"))
#' 
#' # select data for 2 recordings
#' X <- lbh_selec_reference[grep("2|4", lbh_selec_reference$sound.files), ]
#' 
#' # create matrix to determine selections to be used as templates for cross correlation detection
#' cmp.mt <- cbind(paste(X$sound.files, X$selec, sep = "-"), X$sound.files)
#' 
#' # run cross correlation
#' xc.output <- cross_correlation(X = X, output = "list", 
#' compare.matrix = cmp.mt, ovlp = 50, wl = 300, path = tempdir())
#' 
#' # test 6 cutoff values
#' optimize_find_peaks(reference = X, xc.output = xc.output, 
#' cutoffs = seq(0.1, 0.6, by = 0.1))
#' }
#'
#' @references {
#' Araya-Salas, M., & Smith-Vidaurre, G. (2017). warbleR: An R package to streamline analysis of animal acoustic signals. Methods in Ecology and Evolution, 8(2), 184-191.
#' }
#' @seealso \code{\link{optimize_auto_detec}}, \code{\link{find_peaks}}
#' @author Marcelo Araya-Salas (\email{marcelo.araya@@ucr.ac.cr}).
#last modification on dec-21-2021 (MAS)
optimize_find_peaks <- function(xc.output, reference, cutoffs = NULL, parallel = 1, pb = FALSE, by.sound.file = FALSE, previous.output = NULL){
  
  # reset pb on exit
  on.exit(pbapply::pboptions(type = .Options$pboptions$type))
  
  #### set arguments from options
  # get function arguments
  argms <- methods::formalArgs(optimize_auto_detec)
  
  # get warbleR options
  opt.argms <- if(!is.null(getOption("warbleR"))) getOption("warbleR") else SILLYNAME <- 0
  
  # remove options not as default in call and not in function arguments
  opt.argms <- opt.argms[!sapply(opt.argms, is.null) & names(opt.argms) %in% argms]
  
  # get arguments set in the call
  call.argms <- as.list(base::match.call())[-1]
  
  # remove arguments in options that are in call
  opt.argms <- opt.argms[!names(opt.argms) %in% names(call.argms)]
  
  # set options left
  if (length(opt.argms) > 0)
    for (q in 1:length(opt.argms))
      assign(names(opt.argms)[q], opt.argms[[q]])
  
  #if reference is not a data frame
  if (!any(is.data.frame(reference), is_selection_table(reference))) stop("reference is not of a class 'data.frame', 'selection_table'")
  
  if (is_extended_selection_table(reference)) stop("This function cannot take extended selection tables ('reference' argument)")
  
    # check xc.output being a autodetec.output object
    if (!(is(xc.output, "xcorr.output") | is(xc.output, "xc.output"))) 
      stop("'xc.output' must be and object of class 'xcorr.output'")
    
    # check that all sound files in reference have and envelope in xc.output
    if (!all(reference$sound.files %in% gsub("-entire.file$", "", unique(xc.output$scores$sound.files))))
      stop("Not all sound files in 'reference' are found in 'xc.output'")
  
  # if previous output included
  if (!is.null(previous.output))
    cutoffs <- cutoffs[cutoffs %in% previous.output$cutoff]
  
  if (length(cutoffs) == 0){
    cat("all combinations were already evaluated on previous call to this function (based on 'pevious.output')")
    
    performance <- previous.output
  } else {
    
    # subset to sound files in reference
      xc.output$selection.table <- xc.output$selection.table[xc.output$selection.table$sound.files %in% reference$sound.files, ]
      xc.output$envelopes <- xc.output$envelopes[xc.output$envelopes$sound.files %in% reference$sound.files, ]
      xc.output$org.selection.table <- xc.output$org.selection.table[xc.output$org.selection.table$sound.files %in% reference$sound.files, ]
      
    # set pb options
    pbapply::pboptions(type = ifelse(pb, "timer", "none"))
    
    pks_results <- pbapply::pblapply(X = cutoffs, FUN = function(x){
      
      
      pks <- find_peaks(xc.output = xc.output, cutoff = x, output = "data.frame", pb = FALSE, parallel = parallel)
      
      # make factor a character vector
      pks$sound.files <- as.character(pks$sound.files)
      
      pks$..row.id <- 1:nrow(pks)    
      
      pks <- pks[!is.na(pks$start), ]
      
      return(pks)
    })
    
    performance_l <- lapply(pks_results, function(Z) suppressWarnings(diagnose_detection(reference = reference, detection = Z, by.sound.file = by.sound.file, time.diagnostics = FALSE)))   
    
    # put all in a single data frame
    performance <- do.call(rbind, performance_l)
    
    # summarize sound files
    if (by.sound.file)
      cutoffs <- rep(cutoffs, each = nrow(performance_l[[1]]))
      performance <- data.frame(cutoffs = cutoffs, performance)

    
    if (!is.null(previous.output))
      performance <- rbind(previous.output, performance)
    
  }
  return(performance)
}
